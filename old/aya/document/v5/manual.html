
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">


<head profile="http://purl.org/net/ns/metaprof">
 <meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8" />
 <meta http-equiv="content-style-type" content="text/css" />

 <title>old/AYA/ドキュメント/V5/マニュアル - AYAYA/03</title>
 <link rel="stylesheet" href="../../../../style.css" type="text/css" media="screen" charset="UTF-8" />
 <!-- <link rel="stylesheet" href="skin/default.css" type="text/css" media="screen" charset="UTF-8" /> -->
 <!-- <link rel="stylesheet" href="skin/print.css" type="text/css" media="print" charset="UTF-8" /> -->
 <!-- <link rel="stylesheet" href="/svgd/table.css" type="text/css" /> -->
 <!-- <link rel="alternate" type="application/rss+xml" title="RSS" href="index.php?cmd=mixirss&amp;ver=0.91" />  -->
 <script type="text/javascript">
 <!--
 // -->
 IMAGE_DIR = 'image/';
 SKIN_DIR = 'skin/';
 </script>
<!-- <script type="text/javascript" src="skin/lang/.js"></script> -->
<!-- <script type="text/javascript" src="skin/default.js"></script> -->
<!-- <script type="text/javascript" src="skin/ajax/textloader.js"></script> -->
<!-- <script type="text/javascript" src="skin/ajax/glossary.js"></script> -->
 <!-- <script type="text/javascript" src="skin/tzCalculation_LocalTimeZone.js"></script> -->

</head>

<body>
<p id="original_doc_link">https://emily.shillest.net/ayaya/index.php?old/AYA/ドキュメント/V5/マニュアル</p>

<div id="interface_header"></div>

<div id="interface_content">
   <div id="body"><h2 id="content_1_0">AYA Version5 マニュアル<a class="anchor_super" id="z8a62102" href="#z8a62102" style="user-select:none;">&dagger;</a></h2>
<p>このマニュアルは、HTML形式で配布されているものを、すぐに見られるようにWiki上に転記・一部わかりやすいよう加筆したものです。</p>
<p><a href="index.php?old/AYA/document/V5/system_dictionary.html" title="old/AYA/ドキュメント/V5/システム関数" class="link_page_passage">AYA Version5 システム関数</a>も参照してください。</p>
<div class="contents">
<a id="contents_1"></a>
<ul class="list1 list-indent1"><li><a href="#z8a62102">AYA Version5 マニュアル</a></li>
<li><a href="#ja5d0838">概要</a></li>
<li><a href="#ca7d9a37">環境</a></li>
<li><a href="#d695caea">利用規定</a></li>
<li><a href="#i6200e2f">主な変更点</a>
<ul class="list2 list-indent1"><li><a href="#r7165c5b">新機能/改善された機能</a></li>
<li><a href="#dcaed67a">変更された機能</a></li></ul></li>
<li><a href="#ye0e5ed7">エクスポートしている関数</a></li>
<li><a href="#nc75848b">基礎設定</a>
<ul class="list3 list-indent2"><li><a href="#lfff9e83">charset, name</a></li>
<li><a href="#rbfd65d8">dic, filename</a></li>
<li><a href="#ba19005d">msglang, language</a></li>
<li><a href="#m583923d">log, logfilename</a></li>
<li><a href="#pb05622c">iolog, [on|off]</a></li>
<li><a href="#p6bb4967">fncdepth, depth</a></li></ul></li>
<li><a href="#p83ee35b">文スクリプトリファレンス</a></li>
<li><a href="#r29732f5">関数</a>
<ul class="list2 list-indent1"><li><a href="#r94d7456">基礎</a>
<ul class="list3 list-indent1"><li><a href="#f09b1d74">_argc</a></li>
<li><a href="#v1dd42c9">_argv</a></li></ul></li>
<li><a href="#s79234f5">書式</a></li>
<li><a href="#f5f27796">ユーザー関数の定義と実行</a></li>
<li><a href="#vce5bec3">択一</a>
<ul class="list3 list-indent1"><li><a href="#c8db39e4">なにもなし</a></li>
<li><a href="#y4e0c799">nonoverlap</a></li>
<li><a href="#m0d8b091">sequential</a></li>
<li><a href="#sd2e95a2">void</a></li>
<li><a href="#b6965d54">array</a></li></ul></li>
<li><a href="#icb3830b">入れ子</a></li>
<li><a href="#bc934c88">出力確定子</a></li></ul></li>
<li><a href="#n1ee12d5">値と変数</a>
<ul class="list2 list-indent1"><li><a href="#g354a67e">即値</a>
<ul class="list3 list-indent1"><li><a href="#l7eb7352">整数</a></li>
<li><a href="#e2e3fb8f">実数</a></li>
<li><a href="#db427a23">文字列</a></li>
<li><a href="#ea52b392">文字列（展開なし）</a></li></ul></li>
<li><a href="#xb7e9ffb">変数</a></li>
<li><a href="#b50694fc">変数のスコープと寿命</a></li></ul></li>
<li><a href="#q3ea1bb9">演算</a>
<ul class="list2 list-indent1"><li><a href="#v84b1e7f">基本</a></li>
<li><a href="#q7b01c6f">ブラケット( )による演算順序制御</a></li>
<li><a href="#a2371f18">フィードバック演算子&amp;</a></li></ul></li>
<li><a href="#g4feb8c1">配列</a>
<ul class="list2 list-indent1"><li><a href="#u1e86766">簡易配列</a></li>
<li><a href="#r1f9d606">汎用配列</a>
<ul class="list3 list-indent1"><li><a href="#z1cfbf85">初期化</a></li>
<li><a href="#ua3a26fe">要素追加</a></li>
<li><a href="#f152b05f">要素削除</a></li>
<li><a href="#n6fd0d08">値の更新</a></li>
<li><a href="#u9fd841d">値の取り出し</a></li>
<li><a href="#e6240c23">多次元化はできない</a></li>
<li><a href="#z99403e7">演算</a></li>
<li><a href="#se6e58da">関数の引数</a></li>
<li><a href="#o22fa826">デリミタ/取得数指定</a></li></ul></li>
<li><a href="#rce6669c">範囲指定</a></li>
<li><a href="#j8feade9">汎用配列のパラレル出力</a></li></ul></li>
<li><a href="#x744505a">文字列内埋め込み要素の展開</a>
<ul class="list2 list-indent1"><li><a href="#a0bd2710">範囲付き展開</a></li>
<li><a href="#u078e2e3">名称最長一致展開</a></li></ul></li>
<li><a href="#r383aae0">フロー制御</a>
<ul class="list2 list-indent1"><li><a href="#s7f37fda">ifによる分岐</a></li>
<li><a href="#l73d8c0f">caseによる分岐</a></li>
<li><a href="#eded24e4">switchによる分岐</a></li>
<li><a href="#hb9f85fc">ループ</a>
<ul class="list3 list-indent1"><li><a href="#j24fd024">while</a></li>
<li><a href="#hb029288">for</a></li>
<li><a href="#a44ed835">foreach</a></li>
<li><a href="#h5c17692">break</a></li>
<li><a href="#badbffd1">continue</a></li></ul></li>
<li><a href="#ad085d7a">return</a></li></ul></li>
<li><a href="#m573754f">プリプロセス</a>
<ul class="list3 list-indent2"><li><a href="#y197e4c0">#define</a></li>
<li><a href="#r4820e57">#globaldefine</a></li></ul></li>
<li><a href="#wc1ef9d2">予約語</a>
<ul class="list3 list-indent2"><li><a href="#w9fbee0d">システム関数</a></li>
<li><a href="#y0131224">制御構造キーワード</a></li>
<li><a href="#a6b3280c">演算子</a></li></ul></li>
<li><a href="#o6562354">謝辞</a></li></ul>
</div>


<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h2 id="content_1_1">概要<a class="anchor_super" id="ja5d0838" href="#ja5d0838" style="user-select:none;">&dagger;</a></h2>
<p>「あや」と読みます。文字列処理を行なうためのDLLです。
C言語に似た文法を使用して、</p>
<ul class="list1 list-indent1"><li>与えられた文字列を加工する</li>
<li>プログラムした規則に拠って文字列を生成する</li></ul>
<p>といった処理を行なうことが出来ます。
文はWindows DLLですので、直接利用するためには、プログラミングに関する知識がある程度必要です。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h2 id="content_1_2">環境<a class="anchor_super" id="ca7d9a37" href="#ca7d9a37" style="user-select:none;">&dagger;</a></h2>
<p>Windows用です。
開発のごく初期に98SE、2000、xpで動作確認しましたが、最終版はxpでしか確認を取っていません。<br />
報告をいただけると助かります。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h2 id="content_1_3">利用規定<a class="anchor_super" id="d695caea" href="#d695caea" style="user-select:none;">&dagger;</a></h2>
<ul class="list1 list-indent1"><li>使途を限定せず自由に利用することが出来ます。<br /></li>
<li>配布パッケージに含まれているすべてのファイルを自由に取り扱うことが出来ます。一部のファイル、もしくはそのファイルの内容の一部を抜き出して、他の構成に含めてもかまいません。</li>
<li>このプログラムを使用した結果、あなたに何らかの損害が発生しても、その責任を作者は負いません。</li></ul>
<ul class="list1 list-indent1"><li>ソースコードを改変して自由に異版を作成し、配布することが出来ます。<br />
その際、配布者はその意志に基づいたライセンスを独自に策定し配布物に適用することが出来ます。</li></ul>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h2 id="content_1_4">主な変更点<a class="anchor_super" id="i6200e2f" href="#i6200e2f" style="user-select:none;">&dagger;</a></h2>
<p>version 4系列の文をお使いの方は、この項を読むことでversion 5の性能のあらましを簡単に理解できます。<br /></p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_5">新機能/改善された機能<a class="anchor_super" id="r7165c5b" href="#r7165c5b" style="user-select:none;">&dagger;</a></h3>
<ul class="list1 list-indent1"><li>UTF-8に対応<br />
version 4で扱える文字コードはShift_JISのみでしたが、version 5ではShift_JISに加えてUTF-8、およびOSデフォルトの文字コードが使用可能になりました。</li>
<li>数式書式の制限撤廃<br />
関数の引数に数式を記述できない、代入演算子や比較演算子を式に包含できない等の制限がなくなり、自由に式を記述できるようになりました。</li>
<li>if等の真偽判定が0/非0判定へ<br />
version 4ではif等の判定式のために特別の書式が必要でした。version 5にはそのようなものは無く、単に値で判定できます。</li>
<li>汎用配列機能を追加<br />
型を混在して格納可能な配列構造が追加になりました。~文字列を格納する場合でも簡易配列より高速に動作します。</li>
<li>範囲付き埋め込み展開<br />
&quot;hello, %username&quot; を &quot;hello, %(username)&quot; のように書けます。このように( )で囲むと動作速度が向上します。また、( )内はいわゆるeval風に動作するため、たとえば代入式などを文字列内に埋めることが可能になっています。</li>
<li>各種システム関数追加<br />
正規表現、ランダム選択、書式化出力など、従来不可能だった動作を実現する数々の関数が追加されています。</li>
<li>foreach<br />
簡易配列、汎用配列に対してforeachが使えます。</li>
<li>動作速度の向上<br />
実行するスクリプトに強く依存しますが、ループや変数展開などのベンチマーク実測においてversion 4比2～3倍程度という値が出ています。</li>
<li>version 4が抱える問題の解決<br />
version 4はパーサがぬるく、これに起因する種々の不安定動作が大小さまざまな不具合を引き起していました。<br />
version 5ではそのような不安定要因は極力排除されています。</li>
<li>エラーログ改善<br />
ログに記録されえるエラーの内容が詳細化されました。エラー時は該当する辞書ファイル名と行番号が記録されます。</li></ul>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_6">変更された機能<a class="anchor_super" id="dcaed67a" href="#dcaed67a" style="user-select:none;">&dagger;</a></h3>
<p>version 5の開発においては、version 4が抱える不具合や仕様の不整合を矯正することが重視されました。<br />
互換性の確保にも配慮が無かったわけではありませんが、それが足を引っ張るようならきっぱり切り捨てる方針で臨みました。<br />
以下の点で互換性が崩れています。移植の際には注意が必要です。</p>
<ul class="list1 list-indent1"><li>上位/下位インタフェース変更<br />
重要で本質的な変更です。version 4ではHTTP風リクエストヘッダ文字列を送受する構造を前提としていましたが、version 5は特別な書式が決められていない文字列をやりとりするだけです。</li>
<li>システム関数全面見直し<br />
version 4が持つシステム関数のうち、完全に同一機能のまま引き継がれたものは半数程度です。多くが新規追加、廃止、あるいは機能変更されています。詳細はシステム関数リファレンスで確認して下さい。
最も注意を要するのは文字列処理系の関数です。<br />
version 4　STR*系（バイト数単位）、MSTR*系（文字数単位）の二系統が存在<br />
version 5　STR*系（文字数単位）<br />
STR*系関数が残されましたが、動作はMSTR*系のものになっています。これは内部処理がUNICODE化されたためです。</li>
<li>システム変数全廃<br />
_argv、_argc以外のシステム変数は廃止されました。ただし同等機能を持つシステム関数が追加されています。</li>
<li>空の文字列<br />
version 4では空の文字列と値無しの区別が不明確でした。version 5ではこれが厳格に区別されます。</li>
<li>関数/変数名の先頭に数値を使えない<br />
version 4では使用可能でした（そもそも12hourというシステム変数があったほどです）。これはversion 5では禁止となりました。
他にも変数名/関数名として使用不可能になった文字が存在します。</li>
<li>機能制限設定機能は未搭載<br />
考えた結果、とりあえず未実装としました。</li>
<li>そのほか...<br />
version 4のパーサが弱かったおかげで見逃されていたエラーが顕在化する可能性があります。</li></ul>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h2 id="content_1_7">エクスポートしている関数<a class="anchor_super" id="ye0e5ed7" href="#ye0e5ed7" style="user-select:none;">&dagger;</a></h2>
<p>文は以下の公開された関数を持っています。
文を利用するプログラムは、文をLoadLibraryした後にこれらの関数を実行して所望の処理を行ないます。</p>
<pre class="c">extern &quot;C&quot; __declspec(dllexport) BOOL __cdecl load(HGLOBAL h, long len)</pre>
<p>文に初期化を指示します。<br />
文をLoadLibraryして使用を開始する直前に、この関数を一度だけ必ず実行してください。<br />
hには「文がカレントとして認識するディレクトリ絶対パス」を、lenはhの長さを渡してください。
hの領域開放は文側で行ないますので、呼び出し側では使い放しでかまいません。</p>
<pre class="c">extern &quot;C&quot; __declspec(dllexport) BOOL __cdecl unload()</pre>
<p>文に終了を指示します。<br />
文をFreeLibraryする直前に一度だけ実行してください。</p>
<pre class="c">extern &quot;C&quot; __declspec(dllexport) HGLOBAL __cdecl request(HGLOBAL h, long *len)</pre>
<p>文に処理を指示し、結果を得ます。<br />
hには処理対象の文字列を、*lenにhの長さを渡してください。
渡したhの領域開放は文側で行ないますので、呼び出し側では使い放しでかまいません。
処理結果は戻り値で得られます。処理結果の長さは*lenに格納されています（つまりこの値は書き換えられます）。
戻り値を取得した後、領域を*lenで示されるサイズで開放(GlobalFree)してください。</p>
<p>なお、これはデスクトップマスコットソフトウェア「伺か」で使用される擬似AI用DLL「SHIORI」
のインタフェース規格と完全に同一のものです。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h2 id="content_1_8">基礎設定<a class="anchor_super" id="nc75848b" href="#nc75848b" style="user-select:none;">&dagger;</a></h2>
<p>文 ver.5のデフォルトのDLLファイル名は「aya5.dll」です。<br />
主ファイル名「aya5」は他の名前に自由に変更することができます。
文を動作させるためには「基礎設定ファイル」と呼ばれるファイルが必ず必要となります。<br />
基礎設定ファイルのファイル名は「主ファイル名.txt」です。すなわちデフォルトでは「aya5.txt」となります。もしあなたがDLLのファイル名を
「hoge.dll」に変更したなら、基礎設定ファイルは「hoge.txt」です。
基礎設定ファイルはテキストファイルで、実行されるOSのデフォルトの文字コードで解読されます。<br />
もし国際化に関して考慮しなければならないなら、マルチバイト文字コードに関する問題を回避するため、基礎設定ファイルはASCIIコードのみで記述するべきです。
以下に例を示します。</p>
<pre class="aya">// dics
dic, basis.dic
dic, control./*doc*/ayc

// option parameters
charset, UTF-8
msglang, english
log, executelog.txt
iolog, off
fncdepth, 16</pre>
<p>設定はコマンドとパラメータをカンマで区切って指定します。<br />
空行（改行のみの行）、&quot;//&quot;以降、および&quot;/*&quot;と&quot;*/&quot;で囲まれた領域はコメントと見なされます。
コマンドとその意味は以下の通りです。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_9">charset, name<a class="anchor_super" id="lfff9e83" href="#lfff9e83" style="user-select:none;">&dagger;</a></h4>
<p>標準の文字コードを設定します。<br />
以下の予約値からいずれかを指定します。指定が無い場合はShift_JISとして扱われます。</p>
<ul class="list1 list-indent1"><li>Shift_JIS / ShiftJIS / SJIS<br />
シフトJISコード。</li>
<li>UTF-8<br />
UTF-8。</li>
<li>default<br />
実行OSのデフォルト文字コード。</li></ul>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_10">dic, filename<a class="anchor_super" id="rbfd65d8" href="#rbfd65d8" style="user-select:none;">&dagger;</a></h4>
<p>辞書ファイルfilenameをロードします。<br />
辞書ファイルは文スクリプトが記述されたプログラムソースファイルで、文はここのプログラムされた内容を元に動作します。<br />
辞書ファイルはいくつでも指定し、読み込むことができます。
filenameはloadで指定されたパス位置からの相対パスで指定します。
標準の辞書ファイルはcharsetで指定した文字コードで記述されたプレーンテキストファイルです。この他に、一定の法則でスクランブルをかけた
暗号化ファイルを読み込むことができます。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_11">msglang, language<a class="anchor_super" id="ba19005d" href="#ba19005d" style="user-select:none;">&dagger;</a></h4>
<p>ログに記録されるエラーメッセージ類の言語を選択します。<br />
以下の予約値からいずれかを指定します。指定が無い場合はjapaneseとして扱われます。</p>
<ul class="list1 list-indent1"><li>japanese<br />
日本語。</li>
<li>english<br />
英語。</li></ul>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_12">log, logfilename<a class="anchor_super" id="m583923d" href="#m583923d" style="user-select:none;">&dagger;</a></h4>
<p>実行ログをファイルlogfilenameに記録します。<br />
charsetで指定した文字コードで書き込まれます。
logfilenameはloadで指定されたパス位置からの相対パスで指定します。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_13">iolog, [on|off]<a class="anchor_super" id="pb05622c" href="#pb05622c" style="user-select:none;">&dagger;</a></h4>
<p>load、unload、request実行時の入出力文字列と処理時間をログに記録するかを設定します。<br />
onで記録します。デフォルトではonになっていますので、不要の場合にoffとしてください。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_14">fncdepth, depth<a class="anchor_super" id="p6bb4967" href="#p6bb4967" style="user-select:none;">&dagger;</a></h4>
<p>関数呼び出しの深さ上限を数値で指定します。<br />
デフォルト値は32です。最低値は2で、これより小さな値や不正な値を指定した場合も2として扱われます。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h2 id="content_1_15">文スクリプトリファレンス<a class="anchor_super" id="p83ee35b" href="#p83ee35b" style="user-select:none;">&dagger;</a></h2>
<p>文スクリプトの書式はC言語のそれを踏襲しています。<br />
したがってあらかじめC言語、およびC言語に類似する言語を習得していると理解が早いです。<br /></p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h2 id="content_1_16">関数<a class="anchor_super" id="r29732f5" href="#r29732f5" style="user-select:none;">&dagger;</a></h2>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_17">基礎<a class="anchor_super" id="r94d7456" href="#r94d7456" style="user-select:none;">&dagger;</a></h3>
<p>request実行時に&quot;Hello World&quot;という文字列を返すプログラムコードの全体を以下に示します。</p>
<pre class="aya">request
{
    &quot;Hello World&quot;
}</pre>
<p>文をロードしたモジュールがHGLOBAL request(HGLOBAL h, long *len)を実行すると、このスクリプトが実行され、&quot;Hello World&quot;が
返されます。
loadとunloadも同様です。<br />
ただしloadとunloadは値を返さないので、出力文字列を書いても意味がありません。loadには変数に初期値を入れるといった初期化処理を、
unloadには逆にその後始末をするコードを書きます。
必要な関数だけ書けばよいです。不要なものは省けます。<br />
たとえば上の例ではloadとunloadは書いていませんが、これはエラーとはなりません。何もしないだけです。<br />
極端な例を挙げるなら、辞書ファイルがまったく無くてもエラーにはなりません。この場合loadとunloadは何もせず、
requestは空の文字列を返します。</p>
<p>loadとrequestはひとつの引数を持っています。これは変数で取り出せます。<br />
変数の名前は_argcと_argvで、これはC言語のmain関数のインタフェースと類似しています。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_18">_argc<a class="anchor_super" id="f09b1d74" href="#f09b1d74" style="user-select:none;">&dagger;</a></h4>
<p>引数の数。loadとrequestでは引数はひとつの文字列ですから1となります。unloadは引数を持たないので、この値は0となります。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_19">_argv<a class="anchor_super" id="v1dd42c9" href="#v1dd42c9" style="user-select:none;">&dagger;</a></h4>
<p>引数の実体が格納されています。これは_argc個の要素を持つ配列です。各要素へのアクセスは演算子[i]で行います。<br />
序数iは0オリジン指定です。たとえば_argcが1の場合は_argv[0]が使用可能で、ここに引数が格納されていることになります。</p>
<p>基礎編のまとめとして、loadでは変数strに&quot;Hello&quot;を格納し、requestで引数として渡された文字列とstrを結合して返すプログラムコードを
示します。~これまでの説明を踏まえて読んでみてください。</p>
<pre class="aya">load
{
    str = &quot;Hello&quot;
}

request
{
    str + &quot; &quot; + _argv[0] + &quot;!&quot;
}</pre>
<p>処理対象文字列を&quot;World&quot;としてrequestを実行すると、結果として&quot;Hello World!&quot;が得られます。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_20">書式<a class="anchor_super" id="s79234f5" href="#s79234f5" style="user-select:none;">&dagger;</a></h3>
<p>以下の則があります。</p>
<ul class="list1 list-indent1"><li>空行（改行のみの行）、&quot;//&quot;以降、および&quot;/*&quot;と&quot;*/&quot;で囲まれた領域はコメントと見なされます。</li>
<li>1行の終わりがスラッシュ（&quot;/&quot;）の場合は、次の行がこの行の後ろに結合されます。</li>
<li>行頭、および単語間には自由に空白文字を入れることが出来ます。空白文字は空白、およびタブ文字です。</li>
<li>複数のステートメントを1行に詰めて書きたい場合は、セミコロン（&quot;;&quot;）で区切ることが出来ます。</li></ul>
<p>つまり先に挙げたHello Worldコードは以下のように1行に詰めて書くことが出来ます。</p>
<pre class="aya">request{&quot;Hello World&quot;}</pre>
<p>では以下のように書いてもいいのか？　もちろん。問題なく動作します。（ただしこんな風に書くのは感心できない！）</p>
<pre class="aya">req/
uest          {
&quot;/
Hello World&quot;  }</pre>
<p>/の次の行（新たに結合される行）先頭にある空白文字はインデント文字と見なされ、消されます。<br />
したがって以下の文字列の結合結果は &quot;ABCDEFG&quot; であり、決して &quot;ABCD　　EFG&quot; ではありません。</p>
<pre class="aya">&quot;ABCD
    EFG&quot;</pre>
<p>第4項を説明します。<br />
以下のrequestは1+2の答えを求め、日本語の文章にして返しています。</p>
<pre class="aya">request
{
    answer = 1 + 2
    &quot;答えは&quot; + answer + &quot;です。&quot;
}</pre>
<p>セミコロンを使用して以下のように書けます。</p>
<pre class="aya">request
{
    answer = 1 + 2; &quot;答えは&quot; + answer + &quot;です。&quot;
}</pre>
<p>セミコロンは過剰に書いても問題ありません。それらは無視され、動作に影響は与えません。<br />
したがって、あなたがC言語の書式に慣れているなら、各行の終端に必ずセミコロンを書くことができます。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_21">ユーザー関数の定義と実行<a class="anchor_super" id="f5f27796" href="#f5f27796" style="user-select:none;">&dagger;</a></h3>
<p>load、unload、request以外に好きな名前の関数を作成できます。<br />
作成した関数は、その名前を書くだけで実行できます。</p>
<pre class="aya">request
{
    hello
}

hello
{
    &quot;Hello World&quot;
}</pre>
<p>上に示したのはもっとも単純な例です。requestは結果として&quot;Hello World&quot;を返します。
同じ結果が得られるもう少し複雑な例を、以下に示します。</p>
<pre class="aya">request
{
    combine(&quot;Hello&quot;, &quot;World&quot;)
}

combine
{
    _argv[0] + &quot; &quot; + _argv[1]
}</pre>
<p>関数名の後ろに( )をつけて、その中にカンマで値を並べて書くと、これらは該関数に渡される引数として扱われます。
すなわち変数_argvと_argcに値が格納されて、該関数内で参照できるようになります。<br />
ここで挙げた例では、combine関数内において_argcは2、_argv[0]は&quot;Hello&quot;、_argv[1]は&quot;World&quot;となるわけです。
関数名は自由につけられますが、以下に抵触する名前はエラーとなります。</p>
<ul class="list1 list-indent1"><li>数字0～9で始まる。
<ul class="list2 list-indent1"><li>定数の数字として解釈される可能性があります。</li></ul></li>
<li>アンダースコア（&quot;_&quot;）で始まる。
<ul class="list2 list-indent1"><li>アンダースコアで始まる名前はローカル変数で使われています。</li></ul></li>
<li>以下の文字を含む。<br />
空白　!　&quot;　#　$　%　&amp;　(　)　*　+　,　-　/　:　;　&lt;　=　&gt;　?　@　[　]　`　{　|　}　<br />
<ul class="list2 list-indent1"><li>アンダースコア以外の記号は使わないほうが良いでしょう。</li></ul></li>
<li>予約語と完全に一致する。
<ul class="list2 list-indent1"><li>アルファベット大文字＋アンダースコアはシステム関数で使われます。</li>
<li>forやwhile、ifなど、制御構造に使われるものも避けなければいけません。</li></ul></li></ul>
<p>関数は再帰呼び出しが可能です。<br />
もっともありふれた例として階乗計算を行った例を挙げます。</p>
<pre class="aya">request
{
    factorial(5)
}

factorial
{
    if !_argv[0]
        1
    else
        factorial(_argv[0] - 1)*_argv[0]
}</pre>
<p>requestは120を返します。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_22">択一<a class="anchor_super" id="vce5bec3" href="#vce5bec3" style="user-select:none;">&dagger;</a></h3>
<pre class="aya">request
{
    &quot;Hello World&quot;
    &quot;こんにちは世界&quot;
    &quot;Hallo Welt&quot;
}</pre>
<p>このように列挙すると、これらは平等な「出力候補」として扱われ、出力はこれらのうちのいずれかひとつになります。
5種類の選択方法が用意されており、いずれかを選ぶことができます。~ただし、voidとarrayは特殊な用途のみで使用します。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_23">なにもなし<a class="anchor_super" id="c8db39e4" href="#c8db39e4" style="user-select:none;">&dagger;</a></h4>
<p>デフォルトでは無作為に選択します。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_24">nonoverlap<a class="anchor_super" id="y4e0c799" href="#y4e0c799" style="user-select:none;">&dagger;</a></h4>
<p>すべての候補が出力されるまでは、同じ候補を選択しなくなります。</p>
<pre class="aya">request : nonoverlap
{
    &quot;Hello World&quot;
    &quot;こんにちは世界&quot;
    &quot;Hallo Welt&quot;
}</pre>
<p>上のように、関数名の後ろに&quot;: nonoverlap&quot;を付け加えます。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_25">sequential<a class="anchor_super" id="m0d8b091" href="#m0d8b091" style="user-select:none;">&dagger;</a></h4>
<p>記述された順に出力します。最後まで出力したらまた先頭に戻ります。</p>
<pre class="aya">request : sequential
{
    &quot;Hello World&quot;
    &quot;こんにちは世界&quot;
    &quot;Hallo Welt&quot;
}</pre>
<p>上のように、関数名の後ろに&quot;: sequential&quot;を付け加えます。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_26">void<a class="anchor_super" id="sd2e95a2" href="#sd2e95a2" style="user-select:none;">&dagger;</a></h4>
<p>何も出力しなくなります。<br />
以下の例の場合、requestは3つの候補のどれも出力しません。</p>
<pre class="aya">request : void
{
    &quot;Hello World&quot;
    &quot;こんにちは世界&quot;
    &quot;Hallo Welt&quot;
}</pre>
<p>「何も実行しない」ではなく、「何も出力しない」であることに注意してください。<br />
内部に書かれた関数や数式は処理されます。</p>
<pre class="aya">increment_i : void
{
    i++
    i
}</pre>
<p>上の関数increment_iはiに1を加算します。voidが無い場合、この関数は加算結果を返しますが、voidを指定すると値を返さず、
ただ加算を行うのみとなります。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_27">array<a class="anchor_super" id="b6965d54" href="#b6965d54" style="user-select:none;">&dagger;</a></h4>
<p>出力候補をすべて結合した汎用配列を関数の返値とします。<br /></p>
<pre class="aya">request : array
{
　　&quot;This is a pen.&quot;
　　(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)
　　3.14
}</pre>
<p>出力は汎用配列 (&quot;This is a pen.&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, 3.14) となります。</p>
<p>nonoverlapとsequentialは、出力確定子が存在する場合でも取り得るすべての組み合わせに対して正常に機能します。<br />
たとえばsequentialを例に挙げると、</p>
<pre class="aya">request : sequential
{
    &quot;1&quot;
    &quot;2&quot;
    &quot;3&quot;
    --
    &quot;A&quot;
    &quot;B&quot;
}</pre>
<p>requestは以下の順序で出力を発生します。</p>
<pre class="aya">&quot;1A&quot; &quot;2A&quot; &quot;3A&quot; &quot;1B&quot; &quot;2B&quot; &quot;3B&quot; &quot;1A&quot; &quot;2A&quot; …</pre>
<p>関数によっては実行毎に出力候補の数が変動します。~たとえば以下の関数は、変数iの値によって候補数は2個もしくは4個に変化します。</p>
<pre class="aya">request : sequential
{
    if i {
        &quot;1&quot;
        &quot;2&quot;
    }
    &quot;3&quot;
    &quot;4&quot;
}</pre>
<p>候補数が変化した場合、nonoverlapとsequentialの巡回順序は初期化され、最初からやり直しになります。この時に限って、前回と同じ値が重複して
出力されることはあり得ます。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_28">入れ子<a class="anchor_super" id="icb3830b" href="#icb3830b" style="user-select:none;">&dagger;</a></h3>
<pre class="aya">request
{
    {
        &quot;Hello World&quot;
        &quot;こんにちは世界&quot;
    }
    
    &quot;Hallo Welt&quot;
}</pre>
<p>{ } は階層的にいくつでも重ねて書くことが出来ます。動きは最上層の{ }と同じです。すなわち、包含される候補からひとつを選択して出力します。<br />
ただし選択方法は無作為抽出のみで、最上層のようにnonoverlapやsequentialの指定はできません。
上の例では、{ }の有無にかかわらず結果は同じであるように思われるかもしれませんが、実はそうではありません。<br />
{ }が無い場合、それぞれが出力される確率は平等に1/3です。しかし上の例の場合、まず&quot;Hello World&quot;と&quot;こんにちは世界&quot;からひとつが選ばれ、次いでその結果と残った&quot;Hallo Welt&quot;から出力が抽出されます。すなわち、出現率は&quot;Hello World&quot;と&quot;こんにちは世界&quot;が1/4、&quot;Hallo Welt&quot;は1/2となるのです。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_29">出力確定子<a class="anchor_super" id="bc934c88" href="#bc934c88" style="user-select:none;">&dagger;</a></h3>
<pre class="aya">request
{
    &quot;Hello&quot;
    &quot;Perfect&quot;
    &quot;Peaceful&quot;
    --
    &quot; Wor&quot;
    --
    &quot;ld&quot;
    &quot;th&quot;
}</pre>
<ul class="list2 list-indent2"><li>は出力確定子というもので、選択候補はここを区切りとしてグループ分けされます。そして、グループごとに選ばれた結果がひとつの文字列に結合されます。<br />
したがって上のrequestを実行すると、以下のいずれかが出力されることになります。
<pre class="aya">&quot;Hello World&quot;
&quot;Perfect World&quot;
&quot;Peaceful World&quot;
&quot;Hello Worth&quot;
&quot;Perfect Worth&quot;
&quot;Peaceful Worth&quot;</pre></li></ul>
<p>nonoverlap、sequentialと組み合わせて使用した場合、（グループ単位ではなく）関数が取り得る全ての組み合わせに対して動作します。
出力確定子はどこでも問題なく使用できます。{ }入れ子の深い位置でも使えます。
文は文字列のほかに数値なども扱えますが、出力確定子は結合する際にそれらをすべて文字列に変換し、文字列として結合します。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h2 id="content_1_30">値と変数<a class="anchor_super" id="n1ee12d5" href="#n1ee12d5" style="user-select:none;">&dagger;</a></h2>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_31">即値<a class="anchor_super" id="g354a67e" href="#g354a67e" style="user-select:none;">&dagger;</a></h3>
<p>文が扱える値は整数、実数、文字列の3種類です。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_32">整数<a class="anchor_super" id="l7eb7352" href="#l7eb7352" style="user-select:none;">&dagger;</a></h4>
<p>符号付き32bit整数です。
10進数値はそのまま記述します。<br />
先頭に&quot;0b&quot;を付加することにより、2進数値を記述できます。<br />
先頭に&quot;0x&quot;を付加することにより、16進数値を記述できます。
以下の関数int10は整数10を返します。3つの記述はいずれも10進数では10だからです。</p>
<pre class="aya">int10
{
    10
    0b1010
    0xa
}</pre>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_33">実数<a class="anchor_super" id="e2e3fb8f" href="#e2e3fb8f" style="user-select:none;">&dagger;</a></h4>
<p>符号付き64bit浮動小数点数です。小数点以下の桁がある場合や、精度が落ちてもいいので非常に巨大な数値を扱いたい場合はこれを使用します。
整数との区別は小数点の有無です。文は数値に小数点を見つけると、これを実数として取り扱います。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_34">文字列<a class="anchor_super" id="db427a23" href="#db427a23" style="user-select:none;">&dagger;</a></h4>
<p>ダブルクォート（&amp;quot）で囲まれた値は文字列です。
文字列の中にダブルクォートが含まれてはいけません。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_35">文字列（展開なし）<a class="anchor_super" id="ea52b392" href="#ea52b392" style="user-select:none;">&dagger;</a></h4>
<p>シングルクォート（'）で囲まれた値は、展開されない単純な文字列です。<br />
文では文字列中に変数や関数を埋め込むことが出来ますが、これが展開されるのはダブルクォートで囲まれた文字列のみです。
文字列の中にシングルクォートが含まれてはいけません。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_36">変数<a class="anchor_super" id="xb7e9ffb" href="#xb7e9ffb" style="user-select:none;">&dagger;</a></h3>
<p>変数は値を格納するための領域です。<br />
ひとつの変数には、</p>
<ul class="list1 list-indent1"><li>整数、実数、文字列</li>
<li>要素ごとに上記のいずれかを格納可能な汎用配列</li></ul>
<p>を格納することができます。
名前は以下の禁止条項に抵触しない限りは自由につけることができます。</p>
<ul class="list1 list-indent1"><li>数字0～9で始まる。</li>
<li>以下の文字を含む。<br />
空白　!　&quot;　#　$　%　&amp;　(　)　*　+　,　-　/　:　;　&lt;　=　&gt;　?　@　[　]　`　{　|　}　<br /></li>
<li>予約語と完全に一致する。</li>
<li>関数名と完全に一致する。</li></ul>
<p>値の格納（代入）は代入演算子 = で行ないます。内容を出力するには、関数と同様にその名前を書きます。</p>
<pre class="aya">request
{
    str = &quot;こんにちは&quot;
    
    str
}</pre>
<p>上は単純な例で、変数strに文字列を格納し、そのまま出力しています。</p>
<p>まだ値が代入されていない変数は、空の文字列を出力します。~「何も出力しない」ではないことに注意してください。</p>
<pre class="aya">request
{
    &quot;Hello World&quot;
    i
}</pre>
<p>i は存在しません。これは空の文字列になりますから、結局上の例は下のコードと等価であり、&quot;Hello World&quot;もしくは空の文字列を1/2の確率で出力することになります。</p>
<pre class="aya">request
{
    &quot;Hello World&quot;
    &quot;&quot;
}</pre>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_37">変数のスコープと寿命<a class="anchor_super" id="b50694fc" href="#b50694fc" style="user-select:none;">&dagger;</a></h3>
<p>変数はスコープ（有効範囲）の違いによって2種類存在します。</p>
<ul class="list1 list-indent1"><li>グローバル変数<br />
すべての関数で共通に使用できる変数。寿命は永遠。</li>
<li>ローカル変数<br />
現在の{ }内、およびそれより深い入れ子階層のみで使用できる変数。寿命は該当する{ }を抜けるところまで。</li></ul>
<p>両者を区別するのは変数の名前です。変数名の先頭がアンダースコア（&quot;_&quot;）の変数は、ローカル変数として扱われます。
「必要な範囲だけで有効な変数」であるローカル変数をうまく利用することで、プログラムの見通しが良くなります。</p>
<pre class="aya">request
{
    _i = &quot;3*2は&quot;
    
    _j = multi(3)
    
    _i +_j + &quot;です&quot;
}

multi
{
    _i = _argv[0]
    _i * 2
}</pre>
<p>requestとmultiが同じ名前の変数 _i を使っていますが、それらはまったく別物として扱われます。お互いの値を破壊することはありません。
関数の引数を扱う変数_argcと_argvも実はローカル変数であることに気付かれたかと思います。~これらもまた関数ごとに別の値を格納しますので、
ローカル変数になっているわけです。</p>
<p>ローカル変数が「現在の関数内で使用可能な変数」ではなく、「現在の{ }内、およびそれより深い入れ子階層のみで使用できる変数」であることには注意してください。</p>
<pre class="aya">request
{
    {
        _str = &quot;Hello World&quot;
    }

    _str
}</pre>
<p>このプログラムは期待通りには動作しません。<br />
_strは{ }内のみで有効ですから、出力を取り出そうとしている位置では消えてしまっています。<br />
したがって、この関数requestは空の文字列を出力します。
グローバル変数とローカル変数の違いはもうひとつあります。寿命です。<br />
ローカル変数は上で見たとおり、変数を使用している{ }から外れると消えてしまいます。<br />
対してグローバル変数はどこでも使用可能、さらにunloadでその値はファイルへ自動的に保存され、loadで復元されるようになっています。すなわちグローバル変数の内容は、（特殊な操作によって意図的に消去しない限りは）永遠に保持されるのです。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h2 id="content_1_38">演算<a class="anchor_super" id="q3ea1bb9" href="#q3ea1bb9" style="user-select:none;">&dagger;</a></h2>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_39">基本<a class="anchor_super" id="v84b1e7f" href="#v84b1e7f" style="user-select:none;">&dagger;</a></h3>
<p>C言語と同様の書式で四則演算、比較演算、代入、その他が可能です。<br />
演算の順序は演算子毎に重み付けされた演算優先度に基づいて決定されます。また、ブラケット( )で囲まれた部分は最優先で演算されます。
演算子の種類と演算優先度は以下の通りです。</p>
<pre>演算子　　　　　　　　　　　　　　　　　　　　　　意味　　　　　　　　　　優先度

( )　[ ]　　　　　　　　　　　　　　　　　　　　　ブラケット　　　　　　　高い
!　　　　　　　　　　　　　　　　　　　　　　　　 否定
++　--　　　　　　　　　　　　　　　　　　　　　　ポストインクリ/デクリ
*　/　%　　　　　　　　　　　　　　　　　　　　　 乗除算、剰余
+　-　　　　　　　　　　　　　　　　　　　　　　　加減算
&amp;　　　　　　　　　　　　　　　　　　　　　　　　 フィードバック
==　!=　&gt;=　&lt;=　&gt;　&lt;　_in_　!_in_　　　　　　　　 比較
&amp;&amp;　　　　　　　　　　　　　　　　　　　　　　　　論理積
||　　　　　　　　　　　　　　　　　　　　　　　　論理和
=　:=　　　　　　　　　　　　　　　　　　　　　　 代入
+=　-=　*=　/=　%=　+:=　-:=　*:=　/:=　%:=　,=　 演算して代入
,       　　　　　　　　　　　　　　　　　　　　　汎用配列要素の列挙　　　低い</pre>
<p>コロン（&quot;:&quot;）付きの代入演算子は過去互換性を保持するために残されているもので、機能的にはコロン無しのものと同等です。<br /></p>
<p>*は単項演算子です。</p>
<p>ブラケット( )については次項で詳説します。<br />
カンマ演算子（&quot;,&quot;）、およびスクウェアブラケット[ ]については配列の項で詳説しています。<br />
フィードバック演算子&amp;については別項で詳説しています。
_in_と!_in_は文字列の包含チェックに使用する演算子です。</p>
<pre class="aya">foo
{
    &quot;or&quot; _in_ &quot;World&quot;
}</pre>
<p>_in_は左辺の文字列が右辺の文字列に含まれていれば1、含まれていなければ0を返します。!_in_はその逆です。<br />
上の関数fooは1を返します。</p>
<p>比較演算子は結果が真であれば整数1を、偽であれば0を返します。<br />
これらの演算子は文字列に対しても正しく機能します。値の大小は辞書順比較で決定されます。
論理の真偽は以下で判断されます。<br />
偽　整数0、実数0.0、空の文字列、空の汎用配列<br />
真　上記以外のすべて</p>
<p>代入でない演算は結果がそのまま出力となります。</p>
<pre class="aya">foo
{
    (3+2)*4
}</pre>
<p>この関数fooは20を出力します。</p>
<p>同じ優先度の演算子が連続している場合は、常に左から結合されます。</p>
<pre class="aya">1+2-3</pre>
<p>たとえば上の式は</p>
<ol class="list1 list-indent1"><li>1+2</li>
<li>3-3</li></ol>
<p>の順に計算されます。</p>
<pre class="aya">i = j = 10</pre>
<p>これはどうなるでしょう。C言語では代入演算子は右から結合されますから、iとjには10が代入されます。<br />
しかし文では結合は常に左からです。すなわち</p>
<ol class="list1 list-indent1"><li>i = j</li>
<li>j = 10</li></ol>
<p>の順に計算されます。したがって、iには10は入らないのです。</p>
<pre class="aya">i = (j = 10)</pre>
<p>これで i にも10が入るようになります。</p>
<p>演算対象の項の型が一致していない場合、結果の型は以下のようになります。</p>
<ul class="list1 list-indent1"><li>整数と実数の演算<br />
結果は実数となります。</li>
<li>整数/実数と文字列の加算<br />
数値は文字列に変換された後、もう一方の文字列に結合されます。</li>
<li>整数/実数と文字列の演算（加算以外）<br />
演算不能ですがエラーとはなりません。結果は空の文字列となります。</li></ul>
<p>ひとつの演算式内で型が混在していても構いません。<br />
必要に応じて、上記の法則により型変換が起こります。</p>
<pre class="aya">&quot;10+2は&quot; + (10+2) + &quot;です。&quot;</pre>
<p>最初に10+2が整数として計算され、結果12が得られます。残りはすべて文字列との加算ですから、12は文字列に変換され、文字列として結合されます。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_40">ブラケット( )による演算順序制御<a class="anchor_super" id="q7b01c6f" href="#q7b01c6f" style="user-select:none;">&dagger;</a></h3>
<p>ブラケット( )で囲んだ部分は演算順序が最優先扱いになります。<br />
( ) はいくつでも重ねて指定可能で、深くなるほど優先度が上がります。
平たく言えば「かっこで囲んだところを先に計算する」ということです。これは当たり前の規則なのでいまさら大きく扱うまでもないのですが、
数式の書き方によってはなかなかややこしいこともあります。<br />
以下の例を見てください。</p>
<pre class="aya">answer = (_i = 10) + (2*(_i + 10))</pre>
<p>文の演算則をよく理解している人でないと、answerに何が代入されるかを正確に答えることは出来ないでしょう。<br />
answerには文字列の&quot;10&quot;が入ります。決して整数50ではありません。
最初に計算されるのはどこでしょう。ブラケットが一番深いところ、すなわち _i + 10 です。さて変数 _i はまだありません。したがってこれは空の文字列になります。となると、_i + 10 は文字列と整数の加算です。10は文字列に変換され、&quot;10&quot;となります。しかし次が整数との乗算なので、結局また空文字列になってしまいます。<br />
ここまで説明すれば結果が文字列の&quot;10&quot;になる理由は明白でしょう。
さて、こちらの意図ではまず_i = 10の代入を先にしてもらいたいわけです。<br />
このような場合、文では以下のようにブラケットを過剰に付与することで演算順序をコントロールします。</p>
<pre class="aya">answer = (((_i = 10))) + (2*(_i + 10))</pre>
<p>これで代入部分の優先度が一気に引き上げられました。今度は正しい結果が入るはずです。
なお、代入部分を囲むブラケットは2段で十分ではないかと思われるかも知れませんが、それも誤りです。ブラケット2段は_i + 10と同じ深さとなりますが、=と+では優先度が+のほうが高いのです。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_41">フィードバック演算子&amp;<a class="anchor_super" id="a2371f18" href="#a2371f18" style="user-select:none;">&dagger;</a></h3>
<p>フィードバック演算子&amp;は、他の演算子とは使い方がまったく異なる独特の演算子です。</p>
<pre class="aya">request
{
    _i = 1
    foo(&amp;amp;_i)
}

foo
{
    _argv[0] = 100
}</pre>
<p>関数呼び出しの際に引数として変数を与える場合、その先頭に&amp;を書くことができます。
先頭に&amp;を付けられた変数は、呼び出し先関数の_argvの対応する要素へ関連付けられます。すなわち、_argvを書き換えると、対応する呼び出し元の変数の値も書き換わるようになります。<br />
上の例では、fooを実行すると _i の値が100に書き換わります。
フィードバック演算子は好きな位置にいくつでも使用可能です。</p>
<pre class="aya">request
{
    foo(1, 2, &amp;_value, &quot;Hello&quot;, &amp;_value2)
    
    _value + _value2
}

foo
{
    _argv[2] = _argv[0] + _argv[1]
    _argv[4] = _argv[3] + &quot; World&quot;
}</pre>
<p>関数requestは &quot;3Hello World&quot; を出力します。
当然のことですが、フィードバック演算子は変数にしか付けられません。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h2 id="content_1_42">配列<a class="anchor_super" id="g4feb8c1" href="#g4feb8c1" style="user-select:none;">&dagger;</a></h2>
<p>演算子[ ]は配列要素にアクセスするための演算子です。
配列には文字列スプリットを擬似的に配列と見なす「簡易配列」と、カンマ区切りで列挙された要素を扱う「汎用配列」の2種類があります。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_43">簡易配列<a class="anchor_super" id="u1e86766" href="#u1e86766" style="user-select:none;">&dagger;</a></h3>
<p>文字列に含まれるカンマをデリミタ（区切り文字）と解釈して、配列のように扱う機能です。</p>
<pre class="aya">request
{
    _a = &quot;this,is,a,pen&quot;
    _a[1]
}</pre>
<p>requestは&quot;is&quot;を出力します。
[ ]演算子が処理する対象は変数である必要はありません。即値でも関数の返値でもいいです。<br />
上の例は以下のように書いても同じです。</p>
<pre class="aya">request
{
    &quot;this,is,a,pen&quot;[1]
}</pre>
<p>序数の後ろにカンマ区切りでデリミタを指定することにより、カンマでなく他の文字列で簡易配列要素を区切ることができます。<br /></p>
<pre class="aya">request
{
    &quot;This is a island.&quot;[2,&quot;is&quot;]
}</pre>
<p>&quot;is&quot;で区切るわけですから、文字列は以下のように分解されます。<br /></p>
<pre>[0]　&quot;Th&quot;~
[1]　&quot; &quot;~
[2]　&quot; a &quot;~
[3]　&quot;land.&quot;~</pre>
<p>したがってrequestは&quot; a &quot;を返します。
デリミタ指定をうまく使うと、多次元配列風に値を取り出すことが出来ます。</p>
<pre class="aya">request
{
    _ar = &quot;taro|male,ayame|female,hotaru|female&quot;
	
    _ar[2][1,&quot;|&quot;]
}</pre>
<p>_ar[2]は&quot;hotaru|female&quot;です。さらに&quot;|&quot;を区切り文字として解釈して[1]を取り出しますので、結果は&quot;female&quot;となります。
このように、階層毎にユニークなデリミタを適用することによって、任意の位置の値を簡単に抜き出すことができるようになります。
範囲外の序数を指定した場合の出力は、存在しない変数の値を取り出そうとした場合と同様、空の文字列となります。</p>
<p>ここからは変数限定の機能を解説します。
要素に代入が可能です。</p>
<pre class="aya">request
{
    _a = &quot;this,is,a,pen&quot;
    _a[3] = &quot;eraser&quot;
    _a
}</pre>
<p>&quot;pen&quot;を&quot;eraser&quot;に書き換えています。requestの実行結果は&quot;this,is,a,eraser&quot;となります。
デリミタ指定しても正しく機能します。</p>
<pre class="aya">request
{
    _s = &quot;This is a island.&quot;
    _s[2,&quot;is&quot;] = &quot; beautiful &quot;
    _s
}</pre>
<p>requestは&quot;This is beautiful island.&quot;を出力します。
多次元配列風に[ ]演算子を連結して使用している場合、代入はできません。</p>
<pre class="aya">request
{
    _ar = &quot;taro|male,ayame|female,hotaru|female&quot;
	
    _ar[1][1,&quot;|&quot;] = &quot;male&quot;
}</pre>
<p>ayameの性別をmaleに書き換えようとしていますが、この操作はエラーとなります。代入が可能なのは一次元の場合のみです。
現在の要素数を越える位置へも問題なく代入できます。デリミタが自動的に追加され、要素数が拡張されます。</p>
<pre class="aya">request
{
    _m = &quot;fuji/asama/tanigawa&quot;
    _m[5,&quot;/&quot;] = &quot;daisen&quot;
    _m
}</pre>
<p>requestは&quot;fuji/asama/tanigawa///daisen&quot;を出力します。
SETDELIMという関数を使用すると、「デフォルトのデリミタ」をカンマから別の文字列へ変更できます。<br />
先に示した例をSETDELIMを使用して書き換えたものを以下に示します。</p>
<pre class="aya">request
{
    _m = &quot;fuji/asama/tanigawa&quot;
    SETDELIM(_m, &quot;/&quot;)
    _m[5] = &quot;daisen&quot;
    _m
}</pre>
<p>SETDELIMすることにより、単純に_m[5]と書くことができるようになります。
多次元配列風に[ ]演算子を連結して使用している場合、SETDELIMは最初の（一次元目の）[ ]のみで有効です。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_44">汎用配列<a class="anchor_super" id="r1f9d606" href="#r1f9d606" style="user-select:none;">&dagger;</a></h3>
<p>汎用配列はさまざまな型の値を混在して格納できる配列構造です。<br />
一般的なアクセスでは簡易配列より高速に動作します。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_45">初期化<a class="anchor_super" id="z1cfbf85" href="#z1cfbf85" style="user-select:none;">&dagger;</a></h4>
<pre class="aya">i = (100,&quot;test&quot;,-1.5)</pre>
<p>要素をカンマで列挙して記述します。<br />
代入する場合は上のように要素の集合を( )で囲んでください。カンマの演算優先度は代入よりも低いため、ブラケットが無いと</p>
<pre class="aya">(i = 100),&quot;test&quot;,-1.5</pre>
<p>このように解釈されてしまいます。
配列を空の状態で初期化するには、IARRAYという関数を使用します。IARRAYは「空の汎用配列」を返す関数です。</p>
<pre class="aya">i = IARRAY</pre>
<p>初期化時に要素をひとつだけ代入したい場合は工夫が要ります。たとえば単に i = 100 としたのでは、配列ではなくただの数値の代入になってしまうからです。<br />
以下のように記述します。</p>
<pre class="aya">i = (IARRAY,100)</pre>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_46">要素追加<a class="anchor_super" id="ua3a26fe" href="#ua3a26fe" style="user-select:none;">&dagger;</a></h4>
<pre class="aya">i = (i,&quot;add&quot;)</pre>
<p>とすると配列の後端に&quot;add&quot;が追加されます。
配列を追加することもできます。<br /></p>
<pre class="aya">i = (i,(&quot;add&quot;,123,0.0))</pre>
<p>a = a + 1 を a += 1と略せるように、上の例は下のようにも書くことができます。</p>
<pre class="aya">i ,= (&quot;add&quot;,123,0.0)</pre>
<p>先頭への挿入も同じ書式で可能です。</p>
<pre class="aya">i = (&quot;first&quot;,i)</pre>
<p>中途への挿入もできます。</p>
<pre class="aya">i = (100,200,300,400,500,600)
i[2] ,= &quot;insertion&quot;</pre>
<p>iは(100,200,300,&quot;insertion&quot;,400,500,600)となります。<br />
挿入対象は[2]でなく[3]に入ることに注意してください。
i[2]へ挿入したい場合は</p>
<pre class="aya">i[2] = (&quot;insertion&quot;,i[2])</pre>
<p>とします。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_47">要素削除<a class="anchor_super" id="f152b05f" href="#f152b05f" style="user-select:none;">&dagger;</a></h4>
<p>削除したい要素へIARRAYを代入します。</p>
<pre class="aya">i = (100,200,300,400,500,600)
i[2] = IARRAY</pre>
<p>300が削除され、iは(100,200,400,500,600)となります。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_48">値の更新<a class="anchor_super" id="n6fd0d08" href="#n6fd0d08" style="user-select:none;">&dagger;</a></h4>
<p>単純に要素へ代入できます。
現在の要素数を越える位置へも問題なく代入できます。必要な数だけ要素数が拡張されます。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_49">値の取り出し<a class="anchor_super" id="u9fd841d" href="#u9fd841d" style="user-select:none;">&dagger;</a></h4>
<p>通常の変数と同様、序数を指定して記述すればそのまま出力されます。
範囲外の序数を指定した場合の出力は、存在しない変数の値を取り出そうとした場合と同様、空の文字列となります。</p>
<pre class="aya">i = (100,200,300,400,500,600)
i[4]</pre>
<p>500が出力されます。
[ ]演算子が処理する対象は変数である必要はありません。即値でも関数の返値でもいいです。<br /></p>
<pre class="aya">(100,200,300,400,500,600)[4]</pre>
<p>500が出力されます。
汎用配列をそのまま関数の出力にできます。</p>
<pre class="aya">request
{
    river[2]
}

river
{
    &quot;tenryu&quot;,&quot;bandou-tarou&quot;,&quot;ishikari&quot;,&quot;shimanto&quot;
}</pre>
<p>requestは&quot;ishikari&quot;を出力します。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_50">多次元化はできない<a class="anchor_super" id="e6240c23" href="#e6240c23" style="user-select:none;">&dagger;</a></h4>
<p>汎用配列は多次元配列を構成できません。</p>
<pre class="aya">(100,200,(300,400),500,600)</pre>
<p>このように書いても、内包されたブラケット部分が副次的な配列と認識されることはありません。<br />
結局以下のように単純に結合されてしまいます。</p>
<pre class="aya">(100,200,300,400,500,600)</pre>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_51">演算<a class="anchor_super" id="z99403e7" href="#z99403e7" style="user-select:none;">&dagger;</a></h4>
<p>要素単位の演算は通常に行うことが出来ます。
汎用配列と単項値との演算は、「全要素へ単項値が演算される」という独特の動作となります。</p>
<pre class="aya">pref = &quot;gunnma&quot;,&quot;ohsaka&quot;,&quot;hokkaido&quot;
    pref += &quot;-ken&quot;

    answer = (2*(1,2,3))[1]</pre>
<p>prefは &quot;gunnma-ken&quot;,&quot;ohsaka-ken&quot;,&quot;hokkaido-ken&quot; となります。
answerには4が代入されます。<br />
2*(1,2,3)の計算結果が(2,4,6)となるからです。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_52">関数の引数<a class="anchor_super" id="se6e58da" href="#se6e58da" style="user-select:none;">&dagger;</a></h4>
<p>文において関数の引数は汎用配列です。_argvの内容は、呼び出し側引数がそのまま代入された汎用配列となっています。
つまり</p>
<pre class="aya">func(1, 2, &quot;test&quot;)</pre>
<p>という関数の呼び出しは、</p>
<pre class="aya">_i = (1,2,&quot;test&quot;)
func(_i)</pre>
<p>とも書けます。非常にトリッキーな表記ですが、これで意図どおりに動作します。<br />
注意してください。書き直したスクリプトにおいても、引数の数は決して1個ではありません。3個です！
この構造をうまく利用すると、可変長の引数を他の関数へ簡単に渡すことが出来ます。</p>
<pre class="aya">request
{
    total(1,2,3,4,5,6)
}

total
{
    calc_total(_argv)
}

calc_total
{
    _answer = 0;
    foreach _argv; _val { _answer += _val }
    _answer
}</pre>
<p>totalは自分では何もせず、すべての引数をそのままcalc_totalへ引き渡しています。<br />
この例では単純に引き渡していますが、もちろん必要に応じて加工してから渡すことも可能です。
引数の指定方法が複雑になっている場合は注意すべきです。</p>
<pre class="aya">_i = (1,2,&quot;test&quot;)
func(&quot;sky&quot;, _i, &quot;sun&quot;)</pre>
<p>上の呼び出しは以下と等価です。汎用配列は多次元化できないことを思い出してください。</p>
<pre class="aya">func(&quot;sky&quot;, 1, 2, &quot;test&quot;, &quot;sun&quot;)</pre>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_53">デリミタ/取得数指定<a class="anchor_super" id="o22fa826" href="#o22fa826" style="user-select:none;">&dagger;</a></h4>
<pre class="aya">_i = (2,&quot;is&quot;)
&quot;This is a island.&quot;[_i]</pre>
<p>簡易配列のデリミタ指定の部分も汎用配列です。したがって上のようなことも出来ます。これは下の記述と等価です。</p>
<pre class="aya">&quot;This is a island.&quot;[2,&quot;is&quot;]</pre>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_54">範囲指定<a class="anchor_super" id="rce6669c" href="#rce6669c" style="user-select:none;">&dagger;</a></h3>
<p>簡易配列/汎用配列とも、序数を範囲で指定できます。取得、代入とも可能です。
範囲は汎用配列で指定します。たとえば i[a,b] は「iの要素a～b」を表します。</p>
<pre class="aya">name = (&quot;さくら&quot;,&quot;せりこ&quot;,&quot;奈留&quot;,&quot;まゆら&quot;,&quot;毒子&quot;,&quot;美耳&quot;)
i = name[1,3]
name[3,4] = &quot;奎子&quot;
j = name
name[0,2] = IARRAY
k = name</pre>
<p>iには (&quot;せりこ&quot;,&quot;奈留&quot;,&quot;まゆら&quot;) が格納されます。<br />
jは (&quot;さくら&quot;,&quot;せりこ&quot;,&quot;奈留&quot;,&quot;奎子&quot;,&quot;美耳&quot;) 、<br />
kは (&quot;奎子&quot;,&quot;美耳&quot;)  となります。</p>
<p>範囲外は無視されます。</p>
<pre class="aya">n = (1,2,3,4)
n[-2,1] *= 5</pre>
<p>nは (5,10,3,4) です。
対象が簡易配列の場合でも書式は同じです。</p>
<pre class="aya">name = &quot;さくら,せりこ,奈留,まゆら,毒子,美耳&quot;
i = name[1,3]
name[3,4] = &quot;奎子&quot;
j = name</pre>
<p>iは &quot;せりこ,奈留,まゆら&quot; 、jは &quot;さくら,せりこ,奈留,奎子,美耳&quot; です。
デリミタ指定も可能です。範囲指定のすぐ後ろに続けて指定します。</p>
<pre class="aya">animal = &quot;くま！うさぎ！ねこ！いぬ！わに&quot;
i = animal[0,2,&quot;！&quot;]
animal[2,4,&quot;！&quot;] = &quot;ぶた&quot;
j = animal</pre>
<p>iは &quot;くま！うさぎ！ねこ&quot; 、jは &quot;くま！うさぎ！ぶた&quot; です。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_55">汎用配列のパラレル出力<a class="anchor_super" id="j8feade9" href="#j8feade9" style="user-select:none;">&dagger;</a></h3>
<p>すべての式/値の前に「parallel」を書くことができます。<br />
parallelは出力候補値が汎用配列だった場合、
要素のそれぞれを出力候補値にする機能を持っています。</p>
<pre class="aya">foo0
{
　　(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)
　　&quot;地球&quot;
}

foo1
{
　　parallel (&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)
　　&quot;地球&quot;
}</pre>
<p>foo0の出力は、(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) もしくは &quot;地球&quot;。<br />
foo1の出力は、&quot;A&quot;、&quot;B&quot;、&quot;C&quot;、&quot;地球&quot; のいずれかとなります。
汎用配列以外にparallelを使っても意味がなく、書かないのと同じです。たとえば下の2つの記述は等価です。</p>
<pre class="aya">parallel STRLEN(&quot;earth&quot;)
STRLEN(&quot;earth&quot;)</pre>
<p>択一メソッドarrayとparallelを利用することにより、関数の出力候補と汎用配列を相互に変換することができます。<br />
さまざまな応用が考えられます。たとえば以下の非常に簡潔な関数cyclicは、汎用配列から記述順に要素値を取り出します。</p>
<pre class="aya">cyclic : sequential
{
　　parallel _argv
}</pre>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h2 id="content_1_56">文字列内埋め込み要素の展開<a class="anchor_super" id="x744505a" href="#x744505a" style="user-select:none;">&dagger;</a></h2>
<p>文字列の中に変数や関数を埋め込んで、これらの実行結果を当該位置へ挿入することができます。<br /></p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_57">範囲付き展開<a class="anchor_super" id="a0bd2710" href="#a0bd2710" style="user-select:none;">&dagger;</a></h3>
<p>要素を%( )で囲んで埋め込みます。</p>
<pre class="aya">request
{
    _i = &quot;pen&quot;
    &quot;This is a %(_i).&quot;
}</pre>
<p>requestを実行すると、&quot;This is a pen.&quot;が出力されます。
%( )はいわゆるeval（文字列をスクリプトコードと解釈して実行する）のような動作を行います。
単一の関数や変数だけでなく、数式を埋め込むことができます。</p>
<pre class="aya">request
{
    &quot;1+2+3は%(1+2+3)です。&quot;
}</pre>
<p>requestは&quot;1+2+3は6です。&quot;を出力します。</p>
<p>文の文字列は内部にダブルクォートを含むことが出来ない点に注意してください。したがって、文字列を含む数式を埋め込むことは出来ません。以下はエラーです。</p>
<pre class="aya">request
{
    &quot;This is a %(_i = &quot;pen&quot;).&quot;
}</pre>
<p>このような場合は、埋め込みを使用せず通常の数式として結合します。</p>
<pre class="aya">request
{
    &quot;This is a &quot; + (_i = &quot;pen&quot;) + &quot;.&quot;
}</pre>
<p>ブラケット( )による演算順序制御は範囲付き展開でも同様に働きます。~以下の例を見てください。</p>
<pre class="aya">request
{
    &quot;遊星「%(_i = planet)」は遠い。この遊星は%(color(_i))色をしている。&quot;
}

planet
{
    &quot;mars&quot;
    &quot;saturn&quot;
    &quot;pluto&quot;
}

color
{
    case _argv[0] {
    when &quot;mars&quot;;   &quot;red&quot;
    when &quot;saturn&quot;; &quot;yerrow&quot;
    when &quot;pluto&quot;;  &quot;blue&quot;
    others;        &quot;unknown&quot;
    }
}</pre>
<p>最も( )が深いのはcolor(_i)の引数ですので、_i = planetの前にcolorが呼び出されてしまいます。<br />
ブラケットを過剰付与して演算順序を調整してください。</p>
<pre class="aya">&quot;遊星「%((_i = planet))」は遠い。この遊星は%(color(_i))色をしている。&quot;</pre>
<p>これで矛盾の無い文字列が得られるようになります。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_58">名称最長一致展開<a class="anchor_super" id="u078e2e3" href="#u078e2e3" style="user-select:none;">&dagger;</a></h3>
<p>( )を付与せず、単に%のみでも埋め込み展開は機能します。</p>
<pre class="aya">request
{
   o      = &quot;pen&quot;
   obj    = &quot;eraser&quot;
   object = &quot;world&quot;
   &quot;This is a %object.&quot;
}

obje
{
    &quot;television&quot;
}</pre>
<p>展開対象は%以降の文字列に一致する最も長い名前を持った変数/関数となります。上の例の場合、もっともよく一致するのは変数objectですから、これが採用されます。
結果は&quot;This is a world.&quot;となります。
変数は刻々と作成されたり消えたりしますから、展開対象が状況によって変化することになります。<br />
これは範囲付き展開には見られない特徴です。</p>
<pre class="aya">request
{
   val   = &quot;red&quot;
   trans
   --
   value = &quot;blue&quot;
   trans
}

trans
{
    &quot;%value&quot;
}</pre>
<p>transは二度実行されますが、最初と二度目では&quot;%value&quot;の動きが変わります。すなわち、最初は変数val+&quot;ue&quot;、二度目は変数valueと解釈されます。<br />
requestの出力は&quot;redueblue&quot;です。
%[ ]という書式で過去の展開結果を再利用できます。</p>
<pre class="aya">request
{
    &quot;「%planet」は遠い。「%city」も遠い。もっとも%[1]になら行けなくもない。&quot;
}

planet
{
    &quot;mars&quot;
    &quot;saturn&quot;
    &quot;pluto&quot;
}

city
{
    &quot;newyork&quot;
    &quot;moscow&quot;
    &quot;madrid&quot;
}</pre>
<p>%[i]は0オリジンでi番目の展開結果を得ます。<br />
つまり上の例では、%[0]が%planetの、%[1]が%cityの展開結果を示しています。
%[ ]は範囲付き展開では使えません。範囲付き展開で過去の結果を再利用したい場合は、それを変数へ入れてください。</p>
<p>名称最長一致による展開は実行する度に展開対象を検索しなおしますので、範囲付き展開と比べて動作速度が劇的に遅いです。<br />
本当に必要な場合は別ですが、通常は範囲付き展開を利用すべきでしょう。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h2 id="content_1_59">フロー制御<a class="anchor_super" id="r383aae0" href="#r383aae0" style="user-select:none;">&dagger;</a></h2>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_60">ifによる分岐<a class="anchor_super" id="s7f37fda" href="#s7f37fda" style="user-select:none;">&dagger;</a></h3>
<p>式の結果が真であれば以降に続く{ }内を処理します。</p>
<pre class="aya">request
{
    if !i {
        &quot;iは0である。&quot;
    }
}</pre>
<p>すぐ後にelseif節を付加することができます。これはifの判定が偽であった場合のみ処理されます。<br />
いくつでも連結できます。<br />
また、if～elseifの最終端にはelse節を置くことができます。これは先行するifおよびelseifの判定がすべて偽であった場合に
処理されます。</p>
<pre class="aya">request
{
    if !i {
        &quot;iは0である。&quot;
    }
    elseif i == 5 {
        &quot;iは5である。&quot;
    }
    elseif &quot;A&quot; _in_ TOUPPER(i) {
        &quot;iは文字列で、aもしくはAを含んでいる。&quot;
    }
    else {
        &quot;iは0でも5でもaを含む文字列でもない何物かである。&quot;
    }
}</pre>
<p>if、elseif、elseが処理する{ }内にスクリプトが1つしか存在しない場合は、{ }を略せます。したがって上の例は
下のように書きなおすことが出来ます。</p>
<pre class="aya">request
{
    if !i
        &quot;iは0である。&quot;
    elseif i == 5
        &quot;iは5である。&quot;
    elseif &quot;A&quot; _in_ TOUPPER(i)
        &quot;iは文字列で、aもしくはAを含んでいる。&quot;
    else
        &quot;iは0でも5でもaを含む文字列でもない何物かである。&quot;
}</pre>
<p>ただしifが重なっている場合は{ }の省略は出来ません。以下はC言語では正しいですが、文では誤りです。</p>
<pre class="aya">if i == 0
    if j == 0
        &quot;iとjはともに0である。&quot;</pre>
<p>以下のように{ }が必要です。</p>
<pre class="aya">if i == 0 {
    if j == 0
        &quot;iとjはともに0である。&quot;
}</pre>
<p>C言語と同様に、ifの判定式は全体をブラケット( )で囲むことができます。<br />
動作は囲まない場合と変わりません。<br />
if、elseif、case、while、for、switchの判定式で使用できます。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_61">caseによる分岐<a class="anchor_super" id="l73d8c0f" href="#l73d8c0f" style="user-select:none;">&dagger;</a></h3>
<p>caseはラベル分岐構造を実現します。</p>
<pre class="aya">request
{
    case i {
    when 0 {
        &quot;iは0である。&quot;
    }
    when &quot;A&quot;
        &quot;iは文字列Aである。&quot;
    others {
        &quot;iは0でもAでもない。&quot;
    }
    }
}</pre>
<p>caseに与えられた判定式の結果に一致するラベル値を持ったwhen節が実行されます。<br />
others節は、すべてのラベルに合致しなかった場合に実行される部分です。othersは省略できます。省略した場合は何もしません。
ヒットさせるラベル値はカンマで列挙可能です。またマイナス符号でヒットさせる範囲を指定することもできます。</p>
<pre class="aya">request
{
    case name+(i+1) {
    when &quot;Pentium3&quot;,&quot;Pentium4&quot;
        &quot;Pen!!!は1999年、Pen4は2000年発売発売。&quot;
    when &quot;Pentium5&quot;-&quot;PentiumX&quot; {
        &quot;まだ無い。&quot;
    }
    others
        &quot;分からない。&quot;
    }
}</pre>
<p>whenに記述するラベル値は必ず即値でなければなりません。変数や関数、演算子を含む数式は記述できません。
when、othersが処理する{ }内にスクリプトが1つしか存在しない場合は、ifと同様に{ }を省略できます。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_62">switchによる分岐<a class="anchor_super" id="eded24e4" href="#eded24e4" style="user-select:none;">&dagger;</a></h3>
<p>{ }内の出力候補から出力は無作為に選ばれますが、switchを使用すると選択する候補をを位置で指定できます。</p>
<pre class="aya">request
{
    switch id {
        &quot;idは0である。&quot;
        &quot;idは1である。&quot;
        {
            &quot;idは2である。&quot;
            &quot;idはtwoである。&quot;
        }
        &quot;idは&quot;3である。&quot;
    }
}</pre>
<p>変数idの値によって出力される文字列が指定されます。指定は0オリジンです。<br />
idが2の時は、&quot;idは2である。&quot;もしくは&quot;idはtwoである。&quot;が出力されます。この内包された{ }部分では、選択は無作為です。
switchが評価する値に対応する候補が{ }内に存在しない場合は空の文字列が出力されます。たとえば、上の例においてidが100だった場合は空の文字列が出力されます。
switch内に出力確定子がある場合は、各ブロックの該位置にある候補が選択されます。</p>
<pre class="aya">request
{
    switch 1 {
        &quot;かわいい&quot;
        &quot;天才&quot;
        &quot;サル&quot;
        --
        &amp;quot;とは言い難い&quot;
        --
        &quot;ですね。&quot;
        &quot;かもしれません。&quot;
    }
}</pre>
<p>requestの出力は&quot;天才かもしれません。&quot;となります。<br />
中間のブロックには指定位置に候補が無いので、出力が空の文字列となっていることに注意してください。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_63">ループ<a class="anchor_super" id="hb9f85fc" href="#hb9f85fc" style="user-select:none;">&dagger;</a></h3>
<p>while、for、foreachの3種類のループ構造があります。<br /></p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_64">while<a class="anchor_super" id="j24fd024" href="#j24fd024" style="user-select:none;">&dagger;</a></h4>
<p>whileが評価する式が真である間は{ }内を繰り返し処理します。</p>
<pre class="aya">request
{
    _i = 1
    _j = 0
    while _i &lt; 11 {
        _j += _i
        _i++
    }
    
    &quot;1から10をすべて足すと%(_j)である。&quot;
}</pre>
<p>上の例はwhileの機能を簡単に説明しています。
下の例では異なる10個の文字列を発生しています。requestの出力は、1～10のうちいずれかの平方根を報告する文字列です。</p>
<pre class="aya">request
{
    _i = 1
    while _i &lt; 11 {
        &quot;%(_i)の平方根は%(SQRT(_i))である。&quot;
        _i++
    }
}</pre>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_65">for<a class="anchor_super" id="hb029288" href="#hb029288" style="user-select:none;">&dagger;</a></h4>
<p>forはwhileと同様の先判定ループ構造ですが、初期化式、脱出判定式、ループ毎に実行する式を一箇所にまとめて書ける点が優れています。
以下は、whileで挙げた平方根を報告する例をforで書き直したものです。</p>
<pre class="aya">request
{
    for _i = 1; _i &lt; 11; _i++ {
        &quot;%(_i)の平方根は%(SQRT(_i))である。&quot;
    }
}</pre>
<p>_i = 1はループを始める直前に実行されます。_i &lt; 11はループ判定式で、これが真である間はループが続きます。_i++はループの一単位が完了して先頭へ
戻る際に実行される式です。
C言語では for ( ; ; ) とすることで無限ループとできますが、文では各式を省略できません。<br />
無限ループを作る場合は</p>
<pre class="aya">for 1;1;1</pre>
<p>などとしてください。ただ、whileなら</p>
<pre class="aya">while 1</pre>
<p>で済むため、文で無限ループを作る際は、可読性の点からも、動作速度の点からも、whileを使用すべきであると言えます。<br /></p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_66">foreach<a class="anchor_super" id="a44ed835" href="#a44ed835" style="user-select:none;">&dagger;</a></h4>
<p>簡易配列、もしくは汎用配列の各要素値を順番に取り出します。
以下では簡易配列の要素値を取り出して数値へ変換し、すべての合計を計算しています。</p>
<pre class="aya">request
{
    _str = &quot;1,3,5,7,9&quot;
    _t   = 0
    foreach _str; _i {
        _t += TOINT(_i)
    }
    _t
}</pre>
<p>foreachに続いて処理対象を記述します。上の例では簡易配列_strを指定しています。次に書かれた_iは取り出された要素値を格納する変数で、これは
必ず変数でなければなりません。
処理対象の変数のデリミタがSETDELIMによって変更されていても、foreachはそのデリミタを認識して正常に動作します。
foreachは汎用配列も処理できます。</p>
<pre class="aya">request
{
    _sent = (&quot;I&quot;, &quot;am&quot;, 31, &quot;years&quot;, &quot;old.&quot;)
    _t   = &quot;&quot;
    foreach _sent; _i {
        _t += (_i + &quot; &quot;)
    }
    _t
}</pre>
<p>requestは&quot;I am 31 years old. &quot;を出力します。</p>
<p>foreachループ内において要素取り出し対象の簡易配列、汎用配列を書き換えてもかまいません。<br />
変更は正常に反映されます。<br /></p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_67">break<a class="anchor_super" id="h5c17692" href="#h5c17692" style="user-select:none;">&dagger;</a></h4>
<p>ループ中にbreakが現れると、現在実行中の最も深いループから脱出します。</p>
<pre class="aya">request
{
    _j = 0
    for _i = 0; _i &lt; 100; _i++ {
        _j = _i*_i
        if  _j &gt;= 100
            break
    }
    _i - 1
}</pre>
<p>上の例では、forは初期値0の_iが100に達するまでループを実行しようとします。しかし、ループ内には「_i を二乗した結果が 100 を越えたらループから抜ける」ようにbreakが仕込まれています。したがって、実際には _i = 10 の時点でループが終了します。
requestは_iから1を減じた価を返しています。つまりrequestは、二乗した結果が100を越えない最大の整数を求める関数です。 <br /></p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_68">continue<a class="anchor_super" id="badbffd1" href="#badbffd1" style="user-select:none;">&dagger;</a></h4>
<p>ループ中にcontinueが現れると、その位置からすぐにループ先頭へ戻ります。</p>
<pre class="aya">request
{
    _j = &quot;&quot;
    for _i = 0; _i &lt; 3; _i++
    {
        _j += &quot;go &quot;
        if  _i &gt; 0
            continue
        _j += &quot;ahead &quot;
    }
    _j
}</pre>
<p>_iは0、1、2と変化しますが、1、2ではcontinueが働くので、_jに&quot;ahead&quot;を追加する式が実行されません。<br />
したがってrequestの出力は&quot;go ahead go go &quot;となります。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h3 id="content_1_69">return<a class="anchor_super" id="ad085d7a" href="#ad085d7a" style="user-select:none;">&dagger;</a></h3>
<p>returnが現れると、その関数の実行はそこで終わります。<br />
関数の出力はそれまでに蓄積された候補から選ばれます。</p>
<pre class="aya">to_rad
{
    if GETTYPE(_argv[0]) == 3 {
        -1
        return
    }
    _argv[0]*2.0*3.14/360.0
}</pre>
<p>関数to_radはdegreeをradianへ変換します。<br />
引数に文字列が与えられた場合は、if判定でそれを発見して-1を返すようにプログラムされています。returnの時点で出力の候補は-1しか
ありませんから、これが出力されることになります。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h2 id="content_1_70">プリプロセス<a class="anchor_super" id="m573754f" href="#m573754f" style="user-select:none;">&dagger;</a></h2>
<p>プリプロセスは辞書ファイルを読み込んでいる段階で実行される命令です。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_71">#define<a class="anchor_super" id="y197e4c0" href="#y197e4c0" style="user-select:none;">&dagger;</a></h4>
<p>辞書ファイルから読み込んだ（パース前の）生の文字列に対して、直接文字列置換を実行します。</p>
<pre class="aya">#define before after</pre>
<p>とすると、これを記述した行より後ろにbeforeが見つかるたびに、それがafterへ置きかえられます。<br /></p>
<p>#define の有効範囲は、宣言した次の行から、そのファイルの終端までです。
置換は記述順に行われますので、先に変換しておきたいものを先に書いてください。<br /></p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_72">#globaldefine<a class="anchor_super" id="r4820e57" href="#r4820e57" style="user-select:none;">&dagger;</a></h4>
<pre class="aya">#globaldefine before after</pre>
<p>機能は #define ディレクティブと同じです。ただし、有効範囲が異なります。<br /></p>
<p>#globaldefine を宣言すると、次の行以降の全ての範囲（その後に読み込まれる辞書ファイルも含む）で有効になります。
たとえば最初に読み込む辞書ファイルの先頭に #globaldefine を記述すると、その効果はすべての辞書ファイルに及ぶことになります。</p>
<p>#defineが先に処理されます。。#globaldefine は、#define 置換のあとで実行されます。</p>
<pre class="aya">#globaldefine tea green
#define tea milk

&quot;teacup&quot;</pre>
<p>置換結果は&quot;milkcup&quot;となります。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h2 id="content_1_73">予約語<a class="anchor_super" id="wc1ef9d2" href="#wc1ef9d2" style="user-select:none;">&dagger;</a></h2>
<p>以下の単語はシステム関数名、及び制御命令名です。<br />
これらの名前は文システムで予約されています。これらと完全に一致する名称の変数や関数をユーザー側で作成、利用することは出来ません。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_74">システム関数<a class="anchor_super" id="w9fbee0d" href="#w9fbee0d" style="user-select:none;">&dagger;</a></h4>
<p><a href="../../../../old/AYA/document/V5/system_function.html" title="old/AYA/document/V5/System function" class="link_page_passage">../System function</a>で記述されている関数は全て利用できません。<br />
今後の拡張も考えると、大文字＋アンダースコアのみで構成される名前は使わないほうが良いでしょう。</p>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_75">制御構造キーワード<a class="anchor_super" id="y0131224" href="#y0131224" style="user-select:none;">&dagger;</a></h4>
<blockquote><p class="quotation">if　elseif　else　case　when　others　switch　while　for　break　continue　return　foreach</p></blockquote>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h4 id="content_1_76">演算子<a class="anchor_super" id="a6b3280c" href="#a6b3280c" style="user-select:none;">&dagger;</a></h4>
<p>以下の単語/文字は演算子です。<br />
これらと完全に一致する名称の変数や関数をユーザー側で作成、利用することは出来ません。また、変数や関数名の一部にこれらの単語/文字を含むことも出来ません。</p>
<blockquote><p class="quotation">(　)　[　]　!　++　--　*　/　%　+　-　&amp;　==　!=　&lt;=　&gt;=　&lt;　&gt;　_in_　!_in_　&amp;&amp;　||　=　:=　+=　-=　*=　/=　%=　+:=　-:=　*:=　/:=　%:=　,=</p></blockquote>

<div class="jumpmenu"><a href="#navigator">&uarr;</a></div><h2 id="content_1_77">謝辞<a class="anchor_super" id="o6562354" href="#o6562354" style="user-select:none;">&dagger;</a></h2>
<p>以下のライブラリを利用もしくは参考にさせていただきました。感謝致します。</p>
<ul class="list1 list-indent1"><li>マルチバイト文字列 - ワイド文字列変換クラス CUnicodeF<br />
<a href="http://kamoland.com/comp/unicode.html" rel="nofollow">http://kamoland.com/comp/unicode.html</a></li></ul>
<ul class="list1 list-indent1"><li>正規表現ライブラリ Boost::Regex<br />
本家<br />
<a href="http://www.boost.org/libs/regex/doc/index.html" rel="nofollow">http://www.boost.org/libs/regex/doc/index.html</a><br />
日本語訳<br />
<a href="http://boost.cppll.jp/HEAD/libs/regex/index.htm" rel="nofollow">http://boost.cppll.jp/HEAD/libs/regex/index.htm</a><br />
VC6へのインストール方法<br />
<a href="http://village.infoweb.ne.jp/~fwhk9290/behind/regex.htm" rel="nofollow">http://village.infoweb.ne.jp/~fwhk9290/behind/regex.htm</a><br />
基本的な使用方法<br />
<a href="http://www.s34.co.jp/cpptechdoc/article/regexpp/" rel="nofollow">http://www.s34.co.jp/cpptechdoc/article/regexpp/</a><br /></li></ul>
   
   	 	
	</div>
</div>




<table cellspacing=0 width=100%>
<tr><td id=footer>


<div id="lastmodified">
 Last modified on: 2008-03-07 (Friday) 22:08:04<span class="page_passage"></span></div>


<div id="related">
 Related pages: <a href="../../../../startup/making_ghosts_with_yaya.html">StartUp/Making ghosts with YAYA</a><span class="page_passage"></span>
 <a href="../../../../old/aya/document/v5/system_function.html">old/AYA/Document/V5/System function</a><span class="page_passage"></span></div>


</td></tr>
</table>

<div id="interface_footer"></div>

<script src="../../../../interface.js"></script>

</body>
</html>
